
== app/app.go ==
package app

import (
	"database/sql"
	"log"
	"os"

	"github.com/gin-gonic/gin"

	handler "github.com/demkowo/auth/handlers"
	postgres "github.com/demkowo/auth/repositories"
	service "github.com/demkowo/auth/services"

	_ "github.com/lib/pq"
)

const (
	portNumber = ":5000"
)

var (
	dbConnection = os.Getenv("DB_CLIENT")
	router       = gin.Default()
)

func Start() {
	db, err := sql.Open("postgres", dbConnection)
	if err != nil {
		log.Panic(err)
	}
	defer db.Close()

	accountRepo := postgres.NewAccount(db)
	accountService := service.NewAccount(accountRepo)
	accountHandler := handler.NewAccount(accountService)
	addAccountRoutes(accountHandler)

	EnsureTablesExist(db)

	router.Run(portNumber)
}

== app/auth_routes.go ==
package app

import (
	handler "github.com/demkowo/auth/handlers"
)

func addAccountRoutes(h handler.Account) {
	public := router.Group("/api/v1/auth")
	{
		public.POST("/add", h.Add)
		public.POST("/login", h.Login)
		public.POST("/refresh", h.RefreshToken)
		public.GET("/authenticate", h.AuthenticateByAPIKey)
	}

	protected := router.Group("/api/v1/auth")
	{
		protected.POST("/block", h.Block)
		protected.DELETE("/delete/:account_id", h.Delete)
		protected.GET("/find", h.Find)
		protected.GET("/get-by-email/:email", h.GetByEmail)
		protected.GET("/get/:account_id", h.GetById)
		protected.POST("/unblock", h.Unblock)
		protected.PUT("/edit/password", h.UpdatePassword)

		protected.POST("/api-key/:account_id", h.AddAPIKey)
		protected.DELETE("/delete/api-key", h.DeleteAPIKey)

		protected.POST("/roles/add/:account_id", h.AddAccountRole)
		protected.POST("/roles/delete/:account_id", h.DeleteAccountRole)
		protected.GET("/find/roles/:account_id", h.FindRolesByAccount)
		protected.POST("/edit-roles", h.UpdateRoles)
	}
}

== app/create_tables.go ==
package app

import (
	"database/sql"
	"fmt"
)

const (
	ACCOUNT_TABLE_EXIST       = "SELECT to_regclass('public.account');"
	ACCOUNT_ROLES_TABLE_EXIST = "SELECT to_regclass('public.account_roles');"
	APIKEY_TABLE_EXIST        = "SELECT to_regclass('public.api_keys');"

	CREATE_ACCOUNT_TABLE = `
	CREATE TABLE IF NOT EXISTS public.account (
		id UUID PRIMARY KEY,
		nickname VARCHAR(255) NOT NULL,
		email VARCHAR(255) NOT NULL UNIQUE,
		password VARCHAR(255) NOT NULL,
		created TIMESTAMPTZ NOT NULL,
		updated TIMESTAMPTZ NOT NULL,
		blocked TIMESTAMPTZ,
		deleted BOOLEAN NOT NULL DEFAULT FALSE,
		CONSTRAINT account_unique UNIQUE (nickname)
	);
	`

	CREATE_ACCOUNT_ROLES_TABLE = `
	CREATE TABLE IF NOT EXISTS public.account_roles (
		id UUID NOT NULL,
		name VARCHAR(255) NOT NULL,
		PRIMARY KEY (id, name)
	);
	`

	CREATE_APIKEY_TABLE = `
	CREATE TABLE IF NOT EXISTS public.api_keys (
		id UUID PRIMARY KEY,
		key TEXT NOT NULL UNIQUE,
		account_id UUID REFERENCES public.account(id) ON DELETE CASCADE,
		created_at TIMESTAMPTZ NOT NULL,
		expires_at TIMESTAMPTZ
	);
	`
)

func EnsureTablesExist(db *sql.DB) error {
	var tableName sql.NullString

	err := db.QueryRow(ACCOUNT_TABLE_EXIST).Scan(&tableName)
	if err != nil {
		fmt.Printf("failed to execute db.QueryRow ACCOUNT_TABLE_EXIST: %v
", err)
		return err
	}
	if !tableName.Valid {
		fmt.Println("table account does not exist, creating it")
		if _, err := db.Exec(CREATE_ACCOUNT_TABLE); err != nil {
			fmt.Printf("failed to create account table: %v
", err)
			return err
		}
	} else {
		fmt.Println("table account already exists")
	}

	err = db.QueryRow(ACCOUNT_ROLES_TABLE_EXIST).Scan(&tableName)
	if err != nil {
		fmt.Printf("failed to execute db.QueryRow ACCOUNT_ROLES_TABLE_EXIST: %v
", err)
		return err
	}
	if !tableName.Valid {
		fmt.Println("table account_roles does not exist, creating it")
		if _, err := db.Exec(CREATE_ACCOUNT_ROLES_TABLE); err != nil {
			fmt.Printf("failed to create account_roles table: %v
", err)
			return err
		}
	} else {
		fmt.Println("table account_roles already exists")
	}

	err = db.QueryRow(APIKEY_TABLE_EXIST).Scan(&tableName)
	if err != nil {
		fmt.Printf("failed to execute db.QueryRow APIKEY_TABLE_EXIST: %v
", err)
		return err
	}
	if !tableName.Valid {
		fmt.Println("table api_keys does not exist, creating it")
		if _, err := db.Exec(CREATE_APIKEY_TABLE); err != nil {
			fmt.Printf("failed to create api_keys table: %v
", err)
			return err
		}
	} else {
		fmt.Println("table api_keys already exists")
	}

	fmt.Println("All authentication-related tables are ready")
	return nil
}

== config/config.go ==
package config

import (
	"os"
)

var (
	Values config = &conf{}
)

type config interface {
	Get() *conf
}

type conf struct {
	JWTSecret []byte
}

func (m *conf) Get() *conf {
	m.JWTSecret = []byte(os.Getenv("JWT_SECRET"))
	return m
}

== handlers/auth_handler.go ==
package handler

import (
	"log"
	"net/http"
	"strings"
	"time"

	model "github.com/demkowo/auth/models"
	service "github.com/demkowo/auth/services"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Account interface {
	Add(*gin.Context)
	Block(*gin.Context)
	Delete(*gin.Context)
	Find(*gin.Context)
	GetByEmail(*gin.Context)
	GetById(*gin.Context)
	Login(*gin.Context)
	RefreshToken(*gin.Context)
	Unblock(*gin.Context)
	UpdatePassword(*gin.Context)

	AddAPIKey(*gin.Context)
	AuthenticateByAPIKey(*gin.Context)
	DeleteAPIKey(*gin.Context)

	AddAccountRole(*gin.Context)
	DeleteAccountRole(*gin.Context)
	FindRolesByAccount(*gin.Context)
	UpdateRoles(*gin.Context)
}

type account struct {
	service service.Account
}

func NewAccount(service service.Account) Account {
	return &account{service: service}
}

func (h *account) Add(c *gin.Context) {
	var acc model.Account
	if err := c.ShouldBindJSON(&acc); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	if err := acc.Validate(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "email, password and nickname can't be empty"})
	}

	if err := h.service.Add(&acc); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "account registered successfully"})
}

func (h *account) Block(c *gin.Context) {
	var req struct {
		AccountId string `json:"account_id" binding:"required"`
		Until     string `json:"until" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	until, err := time.Parse("2006-01-02", req.Until)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	accountId, err := uuid.Parse(req.AccountId)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id format"})
		return
	}

	if err := h.service.Block(accountId, until); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":       "account blocked successfully",
		"account_id":    accountId,
		"blocked_until": until,
	})
}

func (h *account) Delete(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	if err := h.service.Delete(accountId); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "account deleted successfully"})
}

func (h *account) Find(c *gin.Context) {
	accounts, err := h.service.Find()
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"accounts": accounts})
}

func (h *account) GetByEmail(c *gin.Context) {
	acc, err := h.service.GetByEmail(c.Param("email"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"account": acc})
}

func (h *account) GetById(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid Id"})
		return
	}

	acc, err := h.service.GetById(accountId)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"account": acc})
}

func (h *account) Login(c *gin.Context) {
	var credentials struct {
		Email    string `json:"email" binding:"required,email"`
		Password string `json:"password" binding:"required"`
	}
	if err := c.ShouldBindJSON(&credentials); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	token, err := h.service.Login(credentials.Email, credentials.Password)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"token": token})
}

func (h *account) RefreshToken(c *gin.Context) {
	authHeader := c.GetHeader("Authorization")
	if authHeader == "" {
		log.Println("Authorization header missing")
		c.JSON(http.StatusBadRequest, gin.H{"error": "Authorization header required"})
		return
	}

	parts := strings.SplitN(authHeader, " ", 2)
	if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" {
		log.Println("Invalid Authorization header format")
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Authorization header format"})
		return
	}

	refreshToken := parts[1]

	token, err := h.service.RefreshToken(refreshToken)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"token": token})
}

func (h *account) Unblock(c *gin.Context) {
	var req struct {
		Id string `json:"account_id" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	id, err := uuid.Parse(req.Id)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id format"})
		return
	}

	if err := h.service.Unblock(id); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Account unblocked successfully", "id": id, "unblock_time": time.Now()})
}

func (h *account) UpdatePassword(c *gin.Context) {
	var req struct {
		Id      string `json:"id"`
		OldPass string `json:"old_pass" binding:"required"`
		NewPass string `json:"new_pass" binding:"required"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		log.Println("failed to bind JSON", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	id, err := uuid.Parse(req.Id)
	if err != nil {
		log.Println("uuid.Parse", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	if err := h.service.UpdatePassword(id, req.OldPass, req.NewPass); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

func (h *account) AddAPIKey(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	var request struct {
		ExpiresAt *time.Time `json:"expires_at"`
	}
	if err := c.ShouldBindJSON(&request); err != nil && err.Error() != "EOF" {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	expiresAt := time.Time{}
	if request.ExpiresAt != nil {
		expiresAt = *request.ExpiresAt
	}

	apiKey, errService := h.service.AddAPIKey(accountId, expiresAt)
	if errService != nil {
		log.Println(errService)
		c.JSON(http.StatusInternalServerError, gin.H{"error": errService.Error()})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"api_key": apiKey})
}

func (h *account) AuthenticateByAPIKey(c *gin.Context) {
	apiKey := c.GetHeader("Authorization")
	if apiKey == "" {
		log.Println("empty API Key")
		c.JSON(http.StatusUnauthorized, gin.H{"error": "API key required"})
		return
	}

	apiKey = strings.TrimPrefix(apiKey, "Bearer ")

	account, err := h.service.AuthenticateByAPIKey(apiKey)
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"account_id": account.Id,
		"email":      account.Email,
		"roles":      account.Roles,
	})
}

func (h *account) DeleteAPIKey(c *gin.Context) {
	var request struct {
		APIKey string `json:"api_key" binding:"required"`
	}
	if err := c.ShouldBindJSON(&request); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	if err := h.service.DeleteAPIKey(request.APIKey); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "API key revoked successfully"})
}

func (h *account) AddAccountRole(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	var request struct {
		Role string `json:"role" binding:"required"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	if err := h.service.AddAccountRole(accountId, request.Role); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "role added to account successfully"})
}

func (h *account) DeleteAccountRole(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	var request struct {
		Role string `json:"role" binding:"required"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	if err := h.service.DeleteAccountRole(accountId, request.Role); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "deleting role from account failed"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "role deleted from account successfully"})
}

func (h *account) FindRolesByAccount(c *gin.Context) {
	accountId, err := uuid.Parse(c.Param("account_id"))
	if err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid account Id"})
		return
	}

	roles, errService := h.service.FindRolesByAccount(accountId)
	if errService != nil {
		log.Println(errService)
		c.JSON(http.StatusInternalServerError, gin.H{"error": errService.Error()})
		return
	}

	c.JSON(http.StatusOK, roles)
}

func (h *account) UpdateRoles(c *gin.Context) {
	var req map[string]interface{}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Println(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON data"})
		return
	}

	if err := h.service.UpdateRoles(req); err != nil {
		log.Println(err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "roles updated"})
}

== models/auth_model.go ==
package model

import (
	"errors"
	"regexp"
	"time"

	"github.com/golang-jwt/jwt"
	"github.com/google/uuid"
)

type Account struct {
	Id       uuid.UUID      `json:"id"`
	Email    string         `json:"email"`
	Password string         `json:"password"`
	Nickname string         `json:"nickname"`
	Roles    []AccountRoles `json:"roles"`
	APIKeys  []APIKey       `json:"api_keys"`
	Created  time.Time      `json:"created"`
	Updated  time.Time      `json:"updated"`
	Blocked  time.Time      `json:"blocked"`
	Deleted  bool           `json:"deleted"`
	jwt.StandardClaims
}

type AccountRoles struct {
	Id   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

type APIKey struct {
	Id        uuid.UUID `json:"id"`
	Key       string    `json:"key"`
	AccountId uuid.UUID `json:"account_id"`
	CreatedAt time.Time `json:"created_at"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (a *Account) Validate() error {
	if a.Email == "" || a.Password == "" || a.Nickname == "" {
		return errors.New("email, password and nickname can't be empty")
	}

	emailRegex := regexp.MustCompile(`^[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}$`)
	if !emailRegex.MatchString(a.Email) {
		return errors.New("invalid email address")
	}

	if len(a.Password) < 8 ||
		!containsCapitalLetter(a.Password) ||
		!containsSpecialCharacter(a.Password) ||
		!containsDigit(a.Password) {
		return errors.New("password must contain at least 8 characters, 1 capital letter, 1 special character, and 1 digit")
	}
	return nil
}

func containsCapitalLetter(password string) bool {
	match, _ := regexp.MatchString("[A-Z]", password)
	return match
}

func containsSpecialCharacter(password string) bool {
	match, _ := regexp.MatchString(`[!@#$%^&*()\-_=+\[\]{}|;:'",.<>/?~]`, password)
	return match
}

func containsDigit(password string) bool {
	match, _ := regexp.MatchString("[0-9]", password)
	return match
}

== repositories/auth_repository.go ==
package postgres

import (
	"database/sql"
	"errors"
	"log"
	"time"

	model "github.com/demkowo/auth/models"
	"github.com/google/uuid"
	"github.com/lib/pq"
)

const (
	ADD_ACCOUNT = `
		INSERT INTO public.account (
			id, nickname, email, password, created, updated, blocked, deleted
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8);
	`
	DELETE_ACCOUNT = `
		UPDATE public.account
		SET deleted = TRUE, updated = $1
		WHERE id = $2;
	`
	EDIT_ACCOUNT = `
		UPDATE public.account
		SET email = $1, blocked = $2, updated = $3
		WHERE id = $4;
	`
	EDIT_ACCOUNT_PASSWORD = `
		UPDATE public.account
		SET password = $1, updated = $2
		WHERE id = $3;
	`
	FIND_ACCOUNTS = `
		SELECT 
			account.id, 
			account.nickname, 
			account.email, 
			account.password,
			ARRAY_AGG(account_roles.name) FILTER (WHERE account_roles.name IS NOT NULL) AS role_names,
			account.created, 
			account.updated, 
			account.blocked, 
			account.deleted
		FROM public.account
		LEFT JOIN public.account_roles ON account_roles.id = account.id
		WHERE account.deleted = FALSE
		GROUP BY 
			account.id, 
			account.nickname, 
			account.email, 
			account.password, 
			account.created, 
			account.updated, 
			account.blocked, 
			account.deleted;
	`
	GET_ACCOUNT_BY_EMAIL = `
		SELECT 
			account.id, 
			account.nickname, 
			account.email, 
			account.password, 
			ARRAY_AGG(account_roles.name) FILTER (WHERE account_roles.name IS NOT NULL) AS role_names,
			account.created, 
			account.updated, 
			account.blocked, 
			account.deleted
		FROM public.account
		LEFT JOIN public.account_roles ON account_roles.id = account.id
		WHERE account.deleted = FALSE AND account.email = $1
		GROUP BY 
			account.id, 
			account.nickname, 
			account.email, 
			account.password, 
			account.created, 
			account.updated, 
			account.blocked, 
			account.deleted;
	`
	GET_ACCOUNT_BY_Id = `
		SELECT 
			account.id,
			account.nickname,
			account.email,
			account.password,
			ARRAY_AGG(account_roles.name) FILTER (WHERE account_roles.name IS NOT NULL) AS role_names,
			ARRAY_AGG(api_keys.key) FILTER (WHERE api_keys.key IS NOT NULL) AS api_keys,
			account.created,
			account.updated,
			account.blocked,
			account.deleted
		FROM public.account
		LEFT JOIN public.account_roles ON account_roles.id = account.id
		LEFT JOIN public.api_keys ON api_keys.account_id = account.id
		WHERE account.deleted = FALSE AND account.id = $1
		GROUP BY 
			account.id, 
			account.nickname, 
			account.email, 
			account.password, 
			account.created, 
			account.updated, 
			account.blocked, 
			account.deleted;
	`

	ADD_APIKEY        = "INSERT INTO public.api_keys (id, key, account_id, created_at, expires_at) VALUES ($1, $2, $3, $4, $5);"
	DELETE_APIKEY     = "DELETE FROM public.api_keys WHERE key = $1;"
	GET_APIKEY_BY_Id  = "SELECT id, key, account_id, created_at, expires_at FROM public.api_keys WHERE id = $1;"
	GET_APIKEY_BY_KEY = "SELECT id, key, account_id, created_at, expires_at FROM public.api_keys WHERE key = $1;"

	ADD_ACCOUNT_ROLE         = "INSERT INTO public.account_roles (id, name) VALUES ($1, $2);"
	DELETE_ACCOUNT_ROLE      = "DELETE FROM public.account_roles WHERE id = $1 AND name = $2;"
	FIND_ROLES_BY_ACCOUNT_Id = "SELECT name FROM public.account_roles WHERE id = $1;"
)

type Account interface {
	Add(*model.Account) error
	Delete(uuid.UUID) error
	Find() ([]*model.Account, error)
	GetByEmail(string) (*model.Account, error)
	GetById(uuid.UUID) (*model.Account, error)
	Update(*model.Account) error
	UpdatePassword(uuid.UUID, string) error

	AddAPIKey(*model.APIKey) error
	DeleteAPIKey(string) error
	GetAPIKeyById(uuid.UUID) (*model.APIKey, error)
	GetAPIKeyByKey(string) (*model.APIKey, error)

	AddAccountRole(uuid.UUID, string) error
	DeleteAccountRole(uuid.UUID, string) error
	FindRolesByAccount(uuid.UUID) ([]model.AccountRoles, error)
}

type account struct {
	db *sql.DB
}

func NewAccount(db *sql.DB) Account {
	return &account{
		db: db,
	}
}

func (r *account) Add(acc *model.Account) error {
	now := time.Now()
	acc.Created = now
	acc.Updated = now

	var blocked interface{}
	if acc.Blocked.IsZero() {
		blocked = nil
	} else {
		blocked = acc.Blocked
	}

	_, err := r.db.Exec(ADD_ACCOUNT,
		acc.Id,
		acc.Nickname,
		acc.Email,
		acc.Password,
		acc.Created,
		acc.Updated,
		blocked,
		acc.Deleted,
	)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" {
				log.Printf("duplicate key error on ADD_ACCOUNT: %v", pqErr.Detail)
				return errors.New("account with the given nickname already exists")
			}
		}
		log.Printf("failed to execute db.Exec ADD_ACCOUNT: %v", err)
		return errors.New("failed to create account")
	}

	return nil
}

func (r *account) Delete(accountId uuid.UUID) error {
	_, err := r.db.Exec(DELETE_ACCOUNT, time.Now(), accountId)
	if err != nil {
		log.Printf("failed to execute db.Exec DELETE_ACCOUNT: %v", err)
		return errors.New("failed to delete account")
	}
	return nil
}

func (r *account) Find() ([]*model.Account, error) {
	rows, err := r.db.Query(FIND_ACCOUNTS)
	if err != nil {
		log.Printf("failed to execute db.Query FIND_ACCOUNTS: %v", err)
		return nil, errors.New("failed to find accounts")
	}
	defer rows.Close()

	var accounts []*model.Account
	for rows.Next() {
		var acc model.Account
		var blocked sql.NullTime
		var roleNames pq.StringArray

		if scanErr := rows.Scan(
			&acc.Id,
			&acc.Nickname,
			&acc.Email,
			&acc.Password,
			&roleNames,
			&acc.Created,
			&acc.Updated,
			&blocked,
			&acc.Deleted,
		); scanErr != nil {
			log.Printf("failed to scan rows FIND_ACCOUNTS: %v", scanErr)
			return nil, errors.New("failed to find accounts")
		}

		if blocked.Valid {
			acc.Blocked = blocked.Time
		} else {
			acc.Blocked = time.Time{}
		}

		acc.Roles = make([]model.AccountRoles, len(roleNames))
		for i, roleName := range roleNames {
			acc.Roles[i] = model.AccountRoles{
				Id:   acc.Id,
				Name: roleName,
			}
		}

		accounts = append(accounts, &acc)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		log.Printf("error iterating over accounts: %v", rowsErr)
		return nil, errors.New("failed to find accounts")
	}

	return accounts, nil
}

func (r *account) GetByEmail(email string) (*model.Account, error) {
	row := r.db.QueryRow(GET_ACCOUNT_BY_EMAIL, email)
	var acc model.Account
	var blocked sql.NullTime
	var roleNames pq.StringArray

	err := row.Scan(
		&acc.Id,
		&acc.Nickname,
		&acc.Email,
		&acc.Password,
		&roleNames,
		&acc.Created,
		&acc.Updated,
		&blocked,
		&acc.Deleted,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			log.Printf("account with email %s not found", email)
			return nil, errors.New("account not found")
		}
		log.Printf("failed to scan rows GET_ACCOUNT_BY_EMAIL: %v", err)
		return nil, errors.New("failed to get account")
	}

	if blocked.Valid {
		acc.Blocked = blocked.Time
	} else {
		acc.Blocked = time.Time{}
	}

	acc.Roles = make([]model.AccountRoles, len(roleNames))
	for i, roleName := range roleNames {
		acc.Roles[i] = model.AccountRoles{
			Id:   acc.Id,
			Name: roleName,
		}
	}

	return &acc, nil
}

func (r *account) GetById(id uuid.UUID) (*model.Account, error) {
	row := r.db.QueryRow(GET_ACCOUNT_BY_Id, id)
	var acc model.Account
	var blocked sql.NullTime
	var roleNames pq.StringArray
	var apiKeys pq.StringArray

	err := row.Scan(
		&acc.Id,
		&acc.Nickname,
		&acc.Email,
		&acc.Password,
		&roleNames,
		&apiKeys,
		&acc.Created,
		&acc.Updated,
		&blocked,
		&acc.Deleted,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			log.Printf("account with id %s not found", id)
			return nil, errors.New("account not found")
		}
		log.Printf("failed to scan rows GET_ACCOUNT_BY_Id: %v", err)
		return nil, errors.New("failed to get account")
	}

	if blocked.Valid {
		acc.Blocked = blocked.Time
	} else {
		acc.Blocked = time.Time{}
	}

	acc.Roles = make([]model.AccountRoles, len(roleNames))
	for i, roleName := range roleNames {
		acc.Roles[i] = model.AccountRoles{
			Id:   acc.Id,
			Name: roleName,
		}
	}

	acc.APIKeys = make([]model.APIKey, len(apiKeys))
	for i, keyVal := range apiKeys {
		acc.APIKeys[i] = model.APIKey{
			Id:  acc.Id,
			Key: keyVal,
		}
	}

	return &acc, nil
}

func (r *account) Update(acc *model.Account) error {
	acc.Updated = time.Now()

	var blocked interface{}
	if acc.Blocked.IsZero() {
		blocked = nil
	} else {
		blocked = acc.Blocked
	}

	_, err := r.db.Exec(
		EDIT_ACCOUNT,
		acc.Email,
		blocked,
		acc.Updated,
		acc.Id,
	)
	if err != nil {
		log.Printf("failed to execute db.Exec EDIT_ACCOUNT: %v", err)
		return errors.New("failed to update account")
	}

	return nil
}

func (r *account) UpdatePassword(accountId uuid.UUID, newPassword string) error {
	_, err := r.db.Exec(
		EDIT_ACCOUNT_PASSWORD,
		newPassword,
		time.Now(),
		accountId,
	)
	if err != nil {
		log.Printf("failed to execute db.Exec EDIT_ACCOUNT_PASSWORD: %v", err)
		return errors.New("failed to change password")
	}

	return nil
}

func (r *account) AddAPIKey(apiKey *model.APIKey) error {
	var expiresAt interface{}
	if apiKey.ExpiresAt.IsZero() {
		expiresAt = nil
	} else {
		expiresAt = apiKey.ExpiresAt
	}

	_, err := r.db.Exec(
		ADD_APIKEY,
		apiKey.Id,
		apiKey.Key,
		apiKey.AccountId,
		apiKey.CreatedAt,
		expiresAt,
	)
	if err != nil {
		log.Printf("failed to execute db.Exec ADD_APIKEY: %v", err)
		return errors.New("failed to create API key")
	}

	return nil
}

func (r *account) DeleteAPIKey(key string) error {
	_, err := r.db.Exec(DELETE_APIKEY, key)
	if err != nil {
		log.Printf("failed to execute db.Exec DELETE_APIKEY: %v", err)
		return errors.New("failed to delete API key")
	}

	return nil
}

func (r *account) GetAPIKeyById(id uuid.UUID) (*model.APIKey, error) {
	row := r.db.QueryRow(GET_APIKEY_BY_Id, id)
	var apiKey model.APIKey
	var expiresAt sql.NullTime

	err := row.Scan(
		&apiKey.Id,
		&apiKey.Key,
		&apiKey.AccountId,
		&apiKey.CreatedAt,
		&expiresAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			log.Println("API key not found")
			return nil, errors.New("API key not found")
		}
		log.Printf("failed to execute row.Scan GET_APIKEY_BY_Id: %v", err)
		return nil, errors.New("failed to get API Key")
	}

	if expiresAt.Valid {
		apiKey.ExpiresAt = expiresAt.Time
	} else {
		apiKey.ExpiresAt = time.Time{}
	}

	return &apiKey, nil
}

func (r *account) GetAPIKeyByKey(key string) (*model.APIKey, error) {
	row := r.db.QueryRow(GET_APIKEY_BY_KEY, key)
	var apiKey model.APIKey
	var expiresAt sql.NullTime

	err := row.Scan(
		&apiKey.Id,
		&apiKey.Key,
		&apiKey.AccountId,
		&apiKey.CreatedAt,
		&expiresAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			log.Println("API key not found")
			return nil, errors.New("API key not found")
		}
		log.Printf("failed to execute row.Scan GET_APIKEY_BY_KEY: %v", err)
		return nil, errors.New("failed to get API Key")
	}

	if expiresAt.Valid {
		apiKey.ExpiresAt = expiresAt.Time
	} else {
		apiKey.ExpiresAt = time.Time{}
	}

	return &apiKey, nil
}

func (r *account) AddAccountRole(accountId uuid.UUID, role string) error {
	_, err := r.db.Exec(ADD_ACCOUNT_ROLE, accountId, role)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" {
				log.Printf("duplicate key error on ADD_ACCOUNT: %v", pqErr.Detail)
				return errors.New("this role is already assigned to the account")
			}
		}
		log.Printf("failed to execute ADD_ACCOUNT_ROLE: %v", err)
		return errors.New("failed to add role to account")
	}
	return nil
}

func (r *account) DeleteAccountRole(accountId uuid.UUID, role string) error {
	_, err := r.db.Exec(DELETE_ACCOUNT_ROLE, accountId, role)
	if err != nil {
		log.Printf("failed to execute DELETE_ACCOUNT_ROLE: %v", err)
		return errors.New("failed to delete role from account")
	}
	return nil
}

func (r *account) FindRolesByAccount(accountId uuid.UUID) ([]model.AccountRoles, error) {
	rows, err := r.db.Query(FIND_ROLES_BY_ACCOUNT_Id, accountId)
	if err != nil {
		log.Printf("failed to execute db.Query FIND_ROLES_BY_ACCOUNT_Id: %v", err)
		return nil, errors.New("failed to find roles")
	}
	defer rows.Close()

	var roles []model.AccountRoles
	for rows.Next() {
		var role model.AccountRoles
		if scanErr := rows.Scan(&role.Name); scanErr != nil {
			log.Printf("failed to scan rows FIND_ROLES_BY_ACCOUNT_Id: %v", scanErr)
			return nil, errors.New("failed to find roles")
		}
		role.Id = accountId
		roles = append(roles, role)
	}

	if rowsErr := rows.Err(); rowsErr != nil {
		log.Printf("error while iterating over roles: %v", rowsErr)
		return nil, errors.New("failed to find roles")
	}

	return roles, nil
}

== services/auth_service.go ==
package service

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/demkowo/auth/config"
	model "github.com/demkowo/auth/models"
	"github.com/golang-jwt/jwt"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

var conf = config.Values.Get()

type AccountRepo interface {
	Add(*model.Account) error
	Delete(uuid.UUID) error
	Find() ([]*model.Account, error)
	GetByEmail(string) (*model.Account, error)
	GetById(uuid.UUID) (*model.Account, error)
	Update(*model.Account) error
	UpdatePassword(uuid.UUID, string) error

	AddAPIKey(*model.APIKey) error
	DeleteAPIKey(string) error
	GetAPIKeyById(uuid.UUID) (*model.APIKey, error)
	GetAPIKeyByKey(string) (*model.APIKey, error)

	AddAccountRole(uuid.UUID, string) error
	DeleteAccountRole(uuid.UUID, string) error
	FindRolesByAccount(uuid.UUID) ([]model.AccountRoles, error)
}

type Account interface {
	Add(*model.Account) error
	Block(uuid.UUID, time.Time) error
	CheckAccess(uuid.UUID) error
	Delete(uuid.UUID) error
	Find() ([]*model.Account, error)
	GetByEmail(string) (*model.Account, error)
	GetById(uuid.UUID) (*model.Account, error)
	Login(email, password string) (string, error)
	RefreshToken(refreshToken string) (string, error)
	Unblock(uuid.UUID) error
	UpdatePassword(uuid.UUID, string, string) error

	AddAPIKey(uuid.UUID, time.Time) (string, error)
	AuthenticateByAPIKey(string) (*model.Account, error)
	DeleteAPIKey(string) error

	AddAccountRole(uuid.UUID, string) error
	DeleteAccountRole(uuid.UUID, string) error
	FindRolesByAccount(uuid.UUID) ([]model.AccountRoles, error)
	UpdateRoles(map[string]interface{}) error
}

type account struct {
	repo AccountRepo
}

func NewAccount(repo AccountRepo) Account {
	return &account{repo: repo}
}

func (s *account) Add(acc *model.Account) error {
	if _, err := s.repo.GetByEmail(acc.Email); err == nil {
		return errors.New("an account with this email already exists")
	}

	hashedPassword, err := hashPassword(acc.Password)
	if err != nil {
		return errors.New("failed to create an account")
	}

	acc.Password = hashedPassword
	acc.Id = uuid.New()
	now := time.Now()
	acc.Created = now
	acc.Updated = now
	acc.Blocked = time.Time{}
	acc.Deleted = false

	if err := s.repo.Add(acc); err != nil {
		return err
	}
	return nil
}

func (s *account) Block(accountId uuid.UUID, until time.Time) error {
	acc, err := s.repo.GetById(accountId)
	if err != nil {
		return err
	}

	acc.Blocked = until
	acc.Updated = time.Now()

	if err := s.repo.Update(acc); err != nil {
		return err
	}
	return nil
}

func (s *account) CheckAccess(accountId uuid.UUID) error {
	acc, err := s.repo.GetById(accountId)
	if err != nil {
		return err
	}

	if acc.Deleted {
		log.Println("account is deleted")
		return errors.New("account is deleted")
	}

	if !acc.Blocked.IsZero() && acc.Blocked.After(time.Now()) {
		return fmt.Errorf("account is banned until %s", acc.Blocked.Format(time.RFC3339))
	}

	return nil
}

func (s *account) Delete(accountId uuid.UUID) error {
	if err := s.repo.Delete(accountId); err != nil {
		return err
	}
	return nil
}

func (s *account) Find() ([]*model.Account, error) {
	accounts, err := s.repo.Find()
	if err != nil {
		return nil, err
	}

	for _, acc := range accounts {
		acc.Password = ""
	}
	return accounts, nil
}

func (s *account) GetByEmail(email string) (*model.Account, error) {
	acc, err := s.repo.GetByEmail(email)
	if err != nil {
		return nil, err
	}
	return acc, nil
}

func (s *account) GetById(id uuid.UUID) (*model.Account, error) {
	acc, err := s.repo.GetById(id)
	if err != nil {
		return nil, err
	}
	return acc, nil
}

func (s *account) Login(email, password string) (string, error) {
	acc, err := s.repo.GetByEmail(email)
	if err != nil {
		return "", errors.New("invalid credentials")
	}

	if err := s.CheckAccess(acc.Id); err != nil {
		return "", err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(acc.Password), []byte(password)); err != nil {
		log.Println("invalid credentials due to incorrect password")
		return "", errors.New("invalid credentials")
	}

	tokenString, err := s.addJWTToken(acc)
	if err != nil {
		log.Println("failed to create token:", err)
		return "", errors.New("failed to create token")
	}
	return tokenString, nil
}

func (s *account) RefreshToken(refreshToken string) (string, error) {
	token, err := jwt.Parse(refreshToken, func(token *jwt.Token) (interface{}, error) {
		return conf.JWTSecret, nil
	})
	if err != nil || !token.Valid {
		log.Println("invalid refresh token:", err)
		return "", errors.New("failed to refresh token")
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		log.Println("invalid token claims type")
		return "", errors.New("failed to refresh token")
	}

	accountIdStr, ok := claims["id"].(string)
	if !ok {
		log.Println("invalid token 'id' field")
		return "", errors.New("failed to refresh token")
	}

	accountId, err := uuid.Parse(accountIdStr)
	if err != nil {
		log.Println("invalid account Id in token:", err)
		return "", errors.New("invalid account Id")
	}

	if err := s.CheckAccess(accountId); err != nil {
		log.Println("access check failed:", err)
		return "", errors.New("unauthorized to refresh token")
	}

	acc, err := s.repo.GetById(accountId)
	if err != nil {
		log.Println("failed to get account:", err)
		return "", errors.New("account not found")
	}

	newTokenString, err := s.addJWTToken(acc)
	if err != nil {
		log.Println("failed to create new token:", err)
		return "", errors.New("failed to create token")
	}
	return newTokenString, nil
}

func (s *account) Unblock(accountId uuid.UUID) error {
	acc, err := s.repo.GetById(accountId)
	if err != nil {
		return err
	}

	acc.Blocked = time.Time{}
	acc.Updated = time.Now()

	if err := s.repo.Update(acc); err != nil {
		return err
	}
	return nil
}

func (s *account) UpdatePassword(accountId uuid.UUID, oldPassword, newPassword string) error {
	acc, err := s.repo.GetById(accountId)
	if err != nil {
		return err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(acc.Password), []byte(oldPassword)); err != nil {
		return errors.New("invalid old password")
	}

	hashedPassword, err := hashPassword(newPassword)
	if err != nil {
		return errors.New("failed to change password")
	}

	if err := s.repo.UpdatePassword(accountId, hashedPassword); err != nil {
		return err
	}
	return nil
}

func (s *account) AddAPIKey(accountId uuid.UUID, expiresAt time.Time) (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		log.Println("failed to generate random bytes:", err)
		return "", errors.New("failed to create API Key")
	}

	key := hex.EncodeToString(bytes)

	apiKey := &model.APIKey{
		Id:        uuid.New(),
		Key:       key,
		AccountId: accountId,
		CreatedAt: time.Now(),
		ExpiresAt: expiresAt,
	}

	if err := s.repo.AddAPIKey(apiKey); err != nil {
		return "", err
	}
	return key, nil
}

func (s *account) AuthenticateByAPIKey(apiKey string) (*model.Account, error) {
	apiKeyRecord, err := s.repo.GetAPIKeyByKey(apiKey)
	if err != nil {
		return nil, err
	}

	if !apiKeyRecord.ExpiresAt.IsZero() && time.Now().After(apiKeyRecord.ExpiresAt) {
		return nil, errors.New("API key expired")
	}

	acc, err := s.repo.GetById(apiKeyRecord.AccountId)
	if err != nil {
		return nil, err
	}

	if err := s.CheckAccess(acc.Id); err != nil {
		return nil, err
	}
	return acc, nil
}

func (s *account) DeleteAPIKey(apiKey string) error {
	if err := s.repo.DeleteAPIKey(apiKey); err != nil {
		return err
	}
	return nil
}

func (s *account) AddAccountRole(accountId uuid.UUID, role string) error {
	if err := s.repo.AddAccountRole(accountId, role); err != nil {
		return err
	}

	return nil
}

func (s *account) DeleteAccountRole(accountId uuid.UUID, role string) error {
	if err := s.repo.DeleteAccountRole(accountId, role); err != nil {
		return err
	}

	return nil
}

func (s *account) FindRolesByAccount(accountId uuid.UUID) ([]model.AccountRoles, error) {
	roles, err := s.repo.FindRolesByAccount(accountId)
	if err != nil {
		return nil, err
	}
	return roles, nil
}

func (s *account) UpdateRoles(roles map[string]interface{}) error {
	for key, val := range roles {
		keyParts := strings.Split(key, "_")
		if len(keyParts) != 3 {
			log.Println("invalid key format:", key)
			continue
		}

		accountIdStr := keyParts[1]
		roleName := keyParts[2]

		accountId, err := uuid.Parse(accountIdStr)
		if err != nil {
			log.Printf("failed to parse account Id: %s", accountIdStr)
			continue
		}

		valueStr := fmt.Sprint(val)
		if strings.EqualFold(valueStr, "true") {
			if err := s.repo.AddAccountRole(accountId, roleName); err != nil {
				log.Printf("failed to add role %s to account %s: %v", roleName, accountId, err)
				continue
			}
		} else {
			if err := s.repo.DeleteAccountRole(accountId, roleName); err != nil {
				log.Printf("failed to delete role %s from account %s: %v", roleName, accountId, err)
				continue
			}
		}
	}
	return nil
}

func (s *account) addJWTToken(acc *model.Account) (string, error) {
	expirationTime := time.Now().Add(24 * time.Hour)
	claims := jwt.MapClaims{
		"id":       acc.Id.String(),
		"nickname": acc.Nickname,
		"exp":      expirationTime.Unix(),
		"roles":    extractRoleNames(acc.Roles),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err := token.SignedString(conf.JWTSecret)
	if err != nil {
		log.Println("failed to sign JWT token:", err)
		return "", errors.New("failed to create token")
	}
	return tokenString, nil
}

func extractRoleNames(roles []model.AccountRoles) []string {
	roleNames := make([]string, len(roles))
	for i, role := range roles {
		roleNames[i] = role.Name
	}
	return roleNames
}

func hashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Println("failed to hash password:", err)
		return "", errors.New("failed to hash password")
	}
	return string(bytes), nil
}
